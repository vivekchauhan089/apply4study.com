import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

part 'local_db.g.dart'; // generated by build_runner

// ======= TABLES =======
class Courses extends Table {
  IntColumn get id => integer()();
  TextColumn get title => text().nullable()();
  TextColumn get description => text().nullable()();
  IntColumn get lessons => integer().withDefault(const Constant(0))();
  RealColumn get progress => real().withDefault(const Constant(0.0))();
  TextColumn get videoAsset => text().nullable()();
  TextColumn get category => text().nullable()();
  TextColumn get instructor => text().nullable()();
  DateTimeColumn get updatedAt => dateTime().nullable()();
  @override
  Set<Column> get primaryKey => {id};
}

class ProgressSyncs extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get courseId => integer()();
  RealColumn get progress => real()();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
  BoolColumn get synced => boolean().withDefault(const Constant(false))();
  IntColumn get attempts => integer().withDefault(const Constant(0))();
}

// ======= DATABASE =======
@DriftDatabase(tables: [Courses, ProgressSyncs])
class LocalDb extends _$LocalDb {
  LocalDb() : super(_openConnection()); // âœ… must pass QueryExecutor

  @override
  int get schemaVersion => 1;

  // --- Course helpers ---
  Future<void> upsertCourse(CoursesCompanion entry) =>
      into(courses).insertOnConflictUpdate(entry);

  Future<List<Course>> getAllCourses() => select(courses).get();

  // --- Progress sync helpers ---
  Future<int> addProgressToQueue(int courseId, double progress) {
    return into(progressSyncs).insert(ProgressSyncsCompanion(
      courseId: Value(courseId),
      progress: Value(progress),
      updatedAt: Value(DateTime.now()),
      synced: Value(false),
    ));
  }

  Future<List<ProgressSync>> getPendingProgress(int maxRows) async {
    final rows = await (select(progressSyncs)
          ..where((t) => t.synced.equals(false))
          ..limit(maxRows))
        .get();
    return rows;
  }

  Future<void> markProgressSynced(int id) =>
      (update(progressSyncs)..where((t) => t.id.equals(id)))
          .write(const ProgressSyncsCompanion(synced: Value(true)));

  Future<void> incrementAttempts(int id) async {
    final record = await (select(progressSyncs)..where((t) => t.id.equals(id)))
        .getSingleOrNull();
    if (record != null) {
      await (update(progressSyncs)..where((t) => t.id.equals(id))).write(
        ProgressSyncsCompanion(attempts: Value(record.attempts + 1)),
      );
    }
  }
}

// ======= CONNECTION =======
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File(p.join(dir.path, 'local_db.sqlite'));
    return NativeDatabase(file);
  });
}
