import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:drift/wasm.dart';
import 'package:flutter/foundation.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

// ✅ Import your Drift tables (replace with your actual table files)
import 'tables/courses.dart';
import 'tables/lessons.dart';
import 'tables/progress.dart';

part 'local_db.g.dart'; // generated by build_runner


// ======= DATABASE =======
@DriftDatabase(tables: [Courses, Lessons, ProgressSyncs])
class LocalDb extends _$LocalDb {
  LocalDb() : super(_openConnection()); // ✅ must pass QueryExecutor

  @override
  int get schemaVersion => 1;

  // --- Course helpers ---
  Future<void> upsertCourse(CoursesCompanion entry) =>
      into(courses).insertOnConflictUpdate(entry);

  Future<List<Course>> getAllCourses() => select(courses).get();

  // --- Progress sync helpers ---
  Future<int> addProgressToQueue(int courseId, double progress) {
    return into(progressSyncs).insert(ProgressSyncsCompanion(
      courseId: Value(courseId),
      progress: Value(progress),
      updatedAt: Value(DateTime.now()),
      synced: Value(false),
    ));
  }

  Future<List<ProgressSync>> getPendingProgress(int maxRows) async {
    final rows = await (select(progressSyncs)
          ..where((t) => t.synced.equals(false))
          ..limit(maxRows))
        .get();
    return rows;
  }

  Future<void> markProgressSynced(int id) =>
      (update(progressSyncs)..where((t) => t.id.equals(id)))
          .write(const ProgressSyncsCompanion(synced: Value(true)));

  Future<void> incrementAttempts(int id) async {
    final record = await (select(progressSyncs)..where((t) => t.id.equals(id)))
        .getSingleOrNull();
    if (record != null) {
      await (update(progressSyncs)..where((t) => t.id.equals(id))).write(
        ProgressSyncsCompanion(attempts: Value(record.attempts + 1)),
      );
    }
  }

  // Insert or update (UPSERT) a lesson
  Future<void> upsertLesson(LessonsCompanion entry) async {
    await into(lessons).insertOnConflictUpdate(entry);
  }

  // Get all lessons for a specific course
  Future<List<Lesson>> getLessonsForCourse(int courseId) async {
    final rows = await (select(lessons)
          ..where((tbl) => tbl.courseId.equals(courseId)))
        .get();

    // ✅ Convert Drift row → your Lesson model
    return rows.map((row) => _fromLessonData(row)).toList();
  }

  // Mark lesson completed
  Future<void> markLessonCompleted(int id, {bool synced = false}) async {
    await (update(lessons)..where((l) => l.id.equals(id))).write(
      LessonsCompanion(
        completed: const Value(true),
        synced: Value(synced),
      ),
    );
  }

  // Get unsynced lessons
  Future<List<Lesson>> getUnsyncedLessons() async {
    final rows =
        await (select(lessons)..where((l) => l.synced.equals(false))).get();

    return rows.map((row) => _fromLessonData(row)).toList();
  }

  // Map Drift data to your model
  Lesson _fromLessonData(Lesson data) => Lesson(
    id: data.id,
    courseId: data.courseId,
    title: data.title,
    duration: data.duration,
    completed: data.completed,
    synced: data.synced,
  );

  Future<void> clearAllData() async {
    await delete(courses).go();
    await delete(lessons).go();
    await delete(progressSyncs).go();
  }
  
  Future<void> migrate(int from, int to) async {
    // Handle migrations if needed
  }
}

// ======= CONNECTION =======
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    if (kIsWeb) {
      // ✅ Web: use WASM-based Drift database
      final result = await WasmDatabase.open(
        databaseName: 'localdb',
        sqlite3Uri: Uri.parse('sqlite3.wasm'), // optional
        driftWorkerUri: Uri.parse('drift_worker.js'), // optional
      );
      return result as QueryExecutor;    
    } else{
      // ✅ Mobile/Desktop: use Native database stored in file
      final dir = await getApplicationDocumentsDirectory();
      final file = File(p.join(dir.path, 'local_db.sqlite'));
      return NativeDatabase(file);
    }
  });
}
