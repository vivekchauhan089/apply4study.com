import 'package:drift/drift.dart';

// Conditional import: uses native on mobile/desktop, stub on web
import 'database/app_database_stub.dart'
    if (dart.library.io) 'database/app_database_native.dart';

// ✅ Import your Drift tables (replace with your actual table files)
import 'tables/courses.dart';
import 'tables/lessons.dart';
import 'tables/progress.dart';
import 'tables/health_scans.dart';

part 'local_db.g.dart'; // generated by build_runner


// ======= DATABASE =======
@DriftDatabase(tables: [Courses, Lessons, ProgressSyncs, HealthScans])
class LocalDb extends _$LocalDb {
  LocalDb() : super(openConnection()); // ✅ must pass QueryExecutor

  @override
  int get schemaVersion => 2;

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onUpgrade: (m, from, to) async {
      if (from == 1 && to == 2) {
        await m.createTable(healthScans);
      }
    },
  );

  // --- Course helpers ---
  Future<void> upsertCourse(CoursesCompanion entry) =>
      into(courses).insertOnConflictUpdate(entry);

  Future<List<Course>> getAllCourses() => select(courses).get();

  // --- Progress sync helpers ---
  Future<int> addProgressToQueue(int courseId, double progress) {
    return into(progressSyncs).insert(ProgressSyncsCompanion(
      courseId: Value(courseId),
      progress: Value(progress),
      updatedAt: Value(DateTime.now()),
      synced: Value(false),
    ));
  }

  Future<List<ProgressSync>> getPendingProgress(int maxRows) async {
    final rows = await (select(progressSyncs)
          ..where((t) => t.synced.equals(false))
          ..limit(maxRows))
        .get();
    return rows;
  }

  Future<void> markProgressSynced(int id) =>
      (update(progressSyncs)..where((t) => t.id.equals(id)))
          .write(const ProgressSyncsCompanion(synced: Value(true)));

  Future<void> incrementAttempts(int id) async {
    final record = await (select(progressSyncs)..where((t) => t.id.equals(id)))
        .getSingleOrNull();
    if (record != null) {
      await (update(progressSyncs)..where((t) => t.id.equals(id))).write(
        ProgressSyncsCompanion(attempts: Value(record.attempts + 1)),
      );
    }
  }

  // Insert or update (UPSERT) a lesson
  Future<void> upsertLesson(LessonsCompanion entry) async {
    await into(lessons).insertOnConflictUpdate(entry);
  }

  // Get all lessons for a specific course
  Future<List<Lesson>> getLessonsForCourse(int courseId) async {
    final rows = await (select(lessons)
          ..where((tbl) => tbl.courseId.equals(courseId)))
        .get();

    // ✅ Convert Drift row → your Lesson model
    return rows.map((row) => _fromLessonData(row)).toList();
  }

  // Mark lesson completed
  Future<void> markLessonCompleted(int id, {bool synced = false}) async {
    await (update(lessons)..where((l) => l.id.equals(id))).write(
      LessonsCompanion(
        completed: const Value(true),
        synced: Value(synced),
      ),
    );
  }

  // Get unsynced lessons
  Future<List<Lesson>> getUnsyncedLessons() async {
    final rows =
        await (select(lessons)..where((l) => l.synced.equals(false))).get();

    return rows.map((row) => _fromLessonData(row)).toList();
  }

  // Map Drift data to your model
  Lesson _fromLessonData(Lesson data) => Lesson(
    id: data.id,
    courseId: data.courseId,
    title: data.title,
    duration: data.duration,
    completed: data.completed,
    synced: data.synced,
  );

  Future<void> clearAllData() async {
    await delete(courses).go();
    await delete(lessons).go();
    await delete(progressSyncs).go();
    await delete(healthScans).go();
  }
  


  // --- Health scan helpers ---
  Future<void> saveHealthScan(String mobile, String scanType, String value, String status) async {
    await into(healthScans).insert(HealthScansCompanion(
      mobile: Value(mobile),
      scanType: Value(scanType),
      value: Value(value),
      status: Value(status),
      scanDate: Value(DateTime.now()),
    ));
  }

  Future<List<HealthScan>> getHealthScans(String mobile, {int? days}) async {
    final query = select(healthScans)..where((t) => t.mobile.equals(mobile));
    if (days != null) {
      final cutoff = DateTime.now().subtract(Duration(days: days));
      query.where((t) => t.scanDate.isBiggerOrEqualValue(cutoff));
    }
    query.orderBy([(t) => OrderingTerm.desc(t.scanDate)]);
    return await query.get();
  }

  Future<List<HealthScan>> getHealthScansByType(String mobile, String scanType, {int? days}) async {
    final query = select(healthScans)
      ..where((t) => t.mobile.equals(mobile) & t.scanType.equals(scanType));
    if (days != null) {
      final cutoff = DateTime.now().subtract(Duration(days: days));
      query.where((t) => t.scanDate.isBiggerOrEqualValue(cutoff));
    }
    query.orderBy([(t) => OrderingTerm.asc(t.scanDate)]);
    return await query.get();
  }
}
